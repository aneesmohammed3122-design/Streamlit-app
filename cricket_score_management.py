# -*- coding: utf-8 -*-
"""Cricket Score Management.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12-NiecNgsKbFdIVdq0P5K5fM2xBasnpi
"""





"""# Task
Create a Python application for cricket score management, including data structures for players, teams, innings, and matches, basic scoring functionality, input handling, match flow logic, and score display.

## Define the data structures

### Subtask:
Create Python classes to represent players, teams, innings, and matches.

**Reasoning**:
The subtask requires defining several Python classes. I will define the `Player`, `Team`, `Innings`, and `Match` classes with appropriate attributes to represent the cricket score management system.
"""

class Player:
    def __init__(self, name):
        self.name = name
        self.batting_stats = {"runs": 0, "balls_faced": 0, "fours": 0, "sixes": 0, "is_out": False, "how_out": None}
        self.bowling_stats = {"overs": 0, "runs_given": 0, "wickets": 0, "maidens": 0}

class Team:
    def __init__(self, name, players):
        self.name = name
        self.players = players  # list of Player objects

class Innings:
    def __init__(self, batting_team, bowling_team):
        self.batting_team = batting_team  # Team object
        self.bowling_team = bowling_team  # Team object
        self.runs = 0
        self.wickets = 0
        self.overs_bowled = 0.0
        self.batsmen = []  # list of current batsmen (Player objects)
        self.bowlers = []  # list of bowlers who have bowled (Player objects)

class Match:
    def __init__(self, team1, team2):
        self.team1 = team1  # Team object
        self.team2 = team2  # Team object
        self.innings = []  # list of Innings objects
        self.result = None

"""## Implement basic scoring

### Subtask:
Add functionality to record runs, wickets, and overs.

**Reasoning**:
Add methods to the `Innings` class to handle adding runs, wickets, and overs/balls, and update the `Player` class to track batting and bowling statistics.
"""

class Player:
    def __init__(self, name):
        self.name = name
        self.batting_stats = {"runs": 0, "balls_faced": 0, "fours": 0, "sixes": 0, "is_out": False, "how_out": None}
        self.bowling_stats = {"overs": 0, "runs_given": 0, "wickets": 0, "maidens": 0}

class Team:
    def __init__(self, name, players):
        self.name = name
        self.players = players  # list of Player objects

class Innings:
    def __init__(self, batting_team, bowling_team):
        self.batting_team = batting_team  # Team object
        self.bowling_team = bowling_team  # Team object
        self.runs = 0
        self.wickets = 0
        self.overs_bowled = 0.0
        self.batsmen = []  # list of current batsmen (Player objects)
        self.bowlers = []  # list of bowlers who have bowled (Player objects)
        self.current_batsmen = [] # list of current batsmen at the crease (Player objects)
        self.current_bowler = None # current bowler (Player object)
        self._balls_in_over = 0

    def add_runs(self, runs, striker):
        self.runs += runs
        striker.batting_stats["runs"] += runs
        striker.batting_stats["balls_faced"] += 1
        if runs == 4:
            striker.batting_stats["fours"] += 1
        elif runs == 6:
            striker.batting_stats["sixes"] += 1
        if self.current_bowler:
            self.current_bowler.bowling_stats["runs_given"] += runs
        self._add_ball()

    def add_wicket(self, striker, how_out):
        self.wickets += 1
        striker.batting_stats["is_out"] = True
        striker.batting_stats["how_out"] = how_out
        striker.batting_stats["balls_faced"] += 1
        if striker in self.current_batsmen:
            self.current_batsmen.remove(striker)
        if self.current_bowler:
            self.current_bowler.bowling_stats["wickets"] += 1
        self._add_ball()


    def _add_ball(self):
        self._balls_in_over += 1
        if self._balls_in_over == 6:
            self.overs_bowled += 1
            self._balls_in_over = 0
            # Check for maiden over
            if self.current_bowler and self.current_bowler.bowling_stats["runs_given"] - sum(p.batting_stats["runs"] for p in self.batting_team.players if p in self.current_batsmen) == 0:
                 self.current_bowler.bowling_stats["maidens"] += 1

        else:
            self.overs_bowled += 0.1

    def set_current_batsmen(self, batsman1, batsman2):
        self.current_batsmen = [batsman1, batsman2]
        for batsman in self.current_batsmen:
            if batsman not in self.batsmen:
                self.batsmen.append(batsman)


    def set_current_bowler(self, bowler):
        self.current_bowler = bowler
        if bowler not in self.bowlers:
            self.bowlers.append(bowler)


class Match:
    def __init__(self, team1, team2):
        self.team1 = team1  # Team object
        self.team2 = team2  # Team object
        self.innings = []  # list of Innings objects
        self.result = None

"""## Add input handling

### Subtask:
Create functions to take user input for scores and events during a match.

**Reasoning**:
The subtask requires creating four functions for handling user input: getting integer input, getting string input, getting event input, and selecting a player. I will create these four functions in a single code block.
"""

def get_integer_input(prompt):
    """Gets valid integer input from the user."""
    while True:
        try:
            value = int(input(prompt))
            return value
        except ValueError:
            print("Invalid input. Please enter an integer.")

def get_string_input(prompt):
    """Gets valid non-empty string input from the user."""
    while True:
        value = input(prompt).strip()
        if value:
            return value
        else:
            print("Invalid input. Please enter a non-empty string.")

def get_event_input():
    """Prompts the user for event details and returns a dictionary."""
    event_type = get_string_input("Enter event type (e.g., run, wicket, boundary): ").lower()
    event_details = {"event_type": event_type}

    if event_type == "run":
        runs = get_integer_input("Enter number of runs: ")
        event_details["runs"] = runs
    elif event_type == "wicket":
        how_out = get_string_input("Enter how the batsman was out: ")
        event_details["how_out"] = how_out
    elif event_type == "boundary":
        boundary_type = get_integer_input("Enter boundary type (4 or 6): ")
        event_details["boundary_type"] = boundary_type
        event_details["runs"] = boundary_type # Also add runs for boundary
    # Add more event types as needed

    return event_details

def select_player(team, prompt):
    """Displays players in a team and prompts the user to select one."""
    print(prompt)
    for i, player in enumerate(team.players):
        print(f"{i + 1}. {player.name}")

    while True:
        selection = get_integer_input("Enter player number: ")
        if 1 <= selection <= len(team.players):
            return team.players[selection - 1]
        else:
            print("Invalid selection. Please enter a valid player number.")

"""## Implement match flow

### Subtask:
Develop the logic to manage the progression of an innings and a match.

**Reasoning**:
Implement the methods `start_match`, `start_innings`, `play_ball`, `is_innings_over`, and `play_match` to manage the flow of a cricket match and its innings, handling score updates, wickets, overs, and switching between innings. This addresses instructions 1, 2, 3, 4, 5, 6, and 7 of the current subtask.
"""

class Player:
    def __init__(self, name):
        self.name = name
        self.batting_stats = {"runs": 0, "balls_faced": 0, "fours": 0, "sixes": 0, "is_out": False, "how_out": None}
        self.bowling_stats = {"overs": 0, "runs_given": 0, "wickets": 0, "maidens": 0}

class Team:
    def __init__(self, name, players):
        self.name = name
        self.players = players  # list of Player objects

class Innings:
    def __init__(self, batting_team, bowling_team, max_overs=None, target=None):
        self.batting_team = batting_team  # Team object
        self.bowling_team = bowling_team  # Team object
        self.runs = 0
        self.wickets = 0
        self.overs_bowled = 0.0
        self.batsmen = []  # list of batsmen who have batted (Player objects)
        self.bowlers = []  # list of bowlers who have bowled (Player objects)
        self.current_batsmen = [] # list of current batsmen at the crease (Player objects)
        self.current_bowler = None # current bowler (Player object)
        self._balls_in_over = 0
        self.max_overs = max_overs
        self.target = target
        self.striker = None
        self.non_striker = None

    def add_runs(self, runs, is_extra=False, extra_type=None):
        self.runs += runs
        if not is_extra:
            self.striker.batting_stats["runs"] += runs
            self.striker.batting_stats["balls_faced"] += 1
            if runs == 4:
                self.striker.batting_stats["fours"] += 1
            elif runs == 6:
                self.striker.batting_stats["sixes"] += 1
            if runs % 2 != 0:
                self._swap_strike()
        else:
            if self.current_bowler:
                self.current_bowler.bowling_stats["runs_given"] += runs # Extras also add to bowler's runs
            if extra_type in ["wide", "no-ball"]:
                 # Wide and no-ball don't count as a legal delivery
                return

        if self.current_bowler:
            self.current_bowler.bowling_stats["runs_given"] += runs


    def add_wicket(self, how_out):
        self.wickets += 1
        self.striker.batting_stats["is_out"] = True
        self.striker.batting_stats["how_out"] = how_out
        self.striker.batting_stats["balls_faced"] += 1
        if self.striker in self.current_batsmen:
            self.current_batsmen.remove(self.striker)
        if self.current_bowler:
            self.current_bowler.bowling_stats["wickets"] += 1


    def _add_ball(self, is_extra=False, extra_type=None):
        if is_extra and extra_type in ["wide", "no-ball"]:
            # Wide and no-ball do not count as a legal delivery in the over
            return

        self._balls_in_over += 1
        if self._balls_in_over == 6:
            self.overs_bowled += 1
            self._balls_in_over = 0
            # Check for maiden over (only if no runs were scored on legal deliveries in the over)
            over_runs = self.current_bowler.bowling_stats["runs_given"] - sum(p.batting_stats["runs"] for p in self.batting_team.players if p in self.current_batsmen)
            if over_runs == 0:
                 self.current_bowler.bowling_stats["maidens"] += 1
            self._swap_strike() # Swap strike at the end of the over

        else:
            self.overs_bowled += 0.1 # Represent fractional overs


    def set_current_batsmen(self, batsman1, batsman2):
        self.current_batsmen = [batsman1, batsman2]
        self.striker = batsman1
        self.non_striker = batsman2
        for batsman in self.current_batsmen:
            if batsman not in self.batsmen:
                self.batsmen.append(batsman)


    def set_current_bowler(self, bowler):
        self.current_bowler = bowler
        if bowler not in self.bowlers:
            self.bowlers.append(bowler)

    def _swap_strike(self):
        self.striker, self.non_striker = self.non_striker, self.striker

    def play_ball(self, event_details):
        event_type = event_details["event_type"]

        if event_type == "run":
            runs = event_details["runs"]
            self.add_runs(runs)
            self._add_ball()
        elif event_type == "wicket":
            how_out = event_details["how_out"]
            self.add_wicket(how_out)
            self._add_ball()
            if self.wickets < 10: # If innings not over, bring in new batsman
                 available_batsmen = [p for p in self.batting_team.players if p not in self.batsmen and not p.batting_stats["is_out"]]
                 if available_batsmen:
                     new_batsman = select_player(self.batting_team, "Select the new batsman:")
                     while new_batsman in self.batsmen or new_batsman.batting_stats["is_out"]:
                          print("This player has already batted or is out. Select another player.")
                          new_batsman = select_player(self.batting_team, "Select the new batsman:")
                     self.current_batsmen.append(new_batsman)
                     self.batsmen.append(new_batsman)
                     self.striker = new_batsman # New batsman is usually the striker
                 else:
                      print("No more batsmen available.")

        elif event_type == "boundary":
            runs = event_details["runs"]
            self.add_runs(runs)
            self._add_ball()
        elif event_type == "extra":
            extra_type = event_details["extra_type"]
            runs = event_details.get("runs", 1) # Default to 1 run for most extras
            self.add_runs(runs, is_extra=True, extra_type=extra_type)
            self._add_ball(is_extra=True, extra_type=extra_type)
            if extra_type in ["wide", "no-ball"]:
                print(f"{extra_type.capitalize()} bowled. Another ball to be bowled.")

        # Handle strike change after a legal delivery if odd number of runs are scored
        if event_type not in ["extra"]: # Strike doesn't change automatically for most extras
             if self._balls_in_over != 0 and event_type != "wicket" and event_details.get("runs", 0) % 2 != 0:
                  self._swap_strike()


    def is_innings_over(self):
        if self.wickets >= 10:
            print(f"{self.batting_team.name} all out!")
            return True
        if self.max_overs is not None and self.overs_bowled >= self.max_overs:
            print(f"{self.batting_team.name} finished their overs.")
            return True
        if self.target is not None and self.runs > self.target:
            print(f"{self.batting_team.name} chased down the target!")
            return True
        return False


class Match:
    def __init__(self, team1, team2, max_overs=None):
        self.team1 = team1  # Team object
        self.team2 = team2  # Team object
        self.innings = []  # list of Innings objects
        self.result = None
        self.max_overs = max_overs

    def start_match(self):
        print("Match started!")
        # Decide which team bats first (e.g., through a coin toss)
        # For simplicity, let's say team1 bats first
        batting_team = self.team1
        bowling_team = self.team2
        self.start_innings(batting_team, bowling_team)


    def start_innings(self, batting_team, bowling_team, target=None):
        print(f"\n{batting_team.name} are batting, {bowling_team.name} are bowling.")
        innings = Innings(batting_team, bowling_team, max_overs=self.max_overs, target=target)
        self.innings.append(innings)

        # Select opening batsmen and bowler
        opener1 = select_player(batting_team, f"Select the first opening batsman for {batting_team.name}:")
        opener2 = select_player(batting_team, f"Select the second opening batsman for {batting_team.name}:")
        first_bowler = select_player(bowling_team, f"Select the first bowler for {bowling_team.name}:")

        innings.set_current_batsmen(opener1, opener2)
        innings.set_current_bowler(first_bowler)

        print(f"{innings.striker.name} and {innings.non_striker.name} are batting.")
        print(f"{innings.current_bowler.name} is bowling.")


    def play_match(self):
        self.start_match()

        # First Innings
        current_innings = self.innings[-1]
        while not current_innings.is_innings_over():
            print(f"\nInnings Score: {current_innings.runs}/{current_innings.wickets} Overs: {current_innings.overs_bowled:.1f}")
            print(f"Current Batsmen: {current_innings.striker.name} ({current_innings.striker.batting_stats['runs']}) and {current_innings.non_striker.name} ({current_innings.non_striker.batting_stats['runs']})")
            print(f"Current Bowler: {current_innings.current_bowler.name} ({current_innings.current_bowler.bowling_stats['wickets']}/{current_innings.current_bowler.bowling_stats['runs_given']})")

            event_details = get_event_input()
            current_innings.play_ball(event_details)

            if current_innings._balls_in_over == 0 and not current_innings.is_innings_over(): # End of an over
                new_bowler = select_player(current_innings.bowling_team, f"Select the next bowler for {current_innings.bowling_team.name}:")
                current_innings.set_current_bowler(new_bowler)
                print(f"{current_innings.current_bowler.name} is now bowling.")


        print(f"\nEnd of 1st Innings. {current_innings.batting_team.name} scored {current_innings.runs}/{current_innings.wickets} in {current_innings.overs_bowled:.1f} overs.")

        # Second Innings
        target = current_innings.runs + 1
        print(f"\nTarget for {self.team2.name} is {target}")
        self.start_innings(self.team2, self.team1, target=target)
        current_innings = self.innings[-1]

        while not current_innings.is_innings_over():
            print(f"\nInnings Score: {current_innings.runs}/{current_innings.wickets} Overs: {current_innings.overs_bowled:.1f}")
            print(f"Current Batsmen: {current_innings.striker.name} ({current_innings.striker.batting_stats['runs']}) and {current_innings.non_striker.name} ({current_innings.non_striker.batting_stats['runs']})")
            print(f"Current Bowler: {current_innings.current_bowler.name} ({current_innings.current_bowler.bowling_stats['wickets']}/{current_innings.current_bowler.bowling_stats['runs_given']})")


            event_details = get_event_input()
            current_innings.play_ball(event_details)

            if current_innings._balls_in_over == 0 and not current_innings.is_innings_over(): # End of an over
                new_bowler = select_player(current_innings.bowling_team, f"Select the next bowler for {current_innings.bowling_team.name}:")
                current_innings.set_current_bowler(new_bowler)
                print(f"{current_innings.current_bowler.name} is now bowling.")

        print(f"\nEnd of 2nd Innings. {current_innings.batting_team.name} scored {current_innings.runs}/{current_innings.wickets} in {current_innings.overs_bowled:.1f} overs.")

        # Determine Match Result
        if current_innings.runs > self.innings[0].runs:
            self.result = f"{self.team2.name} won by {10 - current_innings.wickets} wickets."
        elif current_innings.runs < self.innings[0].runs:
            self.result = f"{self.team1.name} won by {self.innings[0].runs - current_innings.runs} runs."
        else:
            self.result = "Match Tied."

        print(f"\nMatch Result: {self.result}")

"""## Display scores

### Subtask:
Create functions to display the current score, wickets, overs, and other relevant information.

**Reasoning**:
Add the `display_scorecard` method to the `Innings` class and modify the `play_match` method in the `Match` class to call it.
"""

class Player:
    def __init__(self, name):
        self.name = name
        self.batting_stats = {"runs": 0, "balls_faced": 0, "fours": 0, "sixes": 0, "is_out": False, "how_out": None}
        self.bowling_stats = {"overs": 0, "runs_given": 0, "wickets": 0, "maidens": 0}

class Team:
    def __init__(self, name, players):
        self.name = name
        self.players = players  # list of Player objects

class Innings:
    def __init__(self, batting_team, bowling_team, max_overs=None, target=None):
        self.batting_team = batting_team  # Team object
        self.bowling_team = bowling_team  # Team object
        self.runs = 0
        self.wickets = 0
        self.overs_bowled = 0.0
        self.batsmen = []  # list of batsmen who have batted (Player objects)
        self.bowlers = []  # list of bowlers who have bowled (Player objects)
        self.current_batsmen = [] # list of current batsmen at the crease (Player objects)
        self.current_bowler = None # current bowler (Player object)
        self._balls_in_over = 0
        self.max_overs = max_overs
        self.target = target
        self.striker = None
        self.non_striker = None

    def add_runs(self, runs, is_extra=False, extra_type=None):
        self.runs += runs
        if not is_extra:
            self.striker.batting_stats["runs"] += runs
            self.striker.batting_stats["balls_faced"] += 1
            if runs == 4:
                self.striker.batting_stats["fours"] += 1
            elif runs == 6:
                self.striker.batting_stats["sixes"] += 1
            if runs % 2 != 0:
                self._swap_strike()
        else:
            if self.current_bowler:
                self.current_bowler.bowling_stats["runs_given"] += runs # Extras also add to bowler's runs
            if extra_type in ["wide", "no-ball"]:
                 # Wide and no-ball don't count as a legal delivery
                return

        if self.current_bowler:
            self.current_bowler.bowling_stats["runs_given"] += runs


    def add_wicket(self, how_out):
        self.wickets += 1
        self.striker.batting_stats["is_out"] = True
        self.striker.batting_stats["how_out"] = how_out
        self.striker.batting_stats["balls_faced"] += 1
        if self.striker in self.current_batsmen:
            self.current_batsmen.remove(self.striker)
        if self.current_bowler:
            self.current_bowler.bowling_stats["wickets"] += 1


    def _add_ball(self, is_extra=False, extra_type=None):
        if is_extra and extra_type in ["wide", "no-ball"]:
            # Wide and no-ball do not count as a legal delivery in the over
            return

        self._balls_in_over += 1
        if self._balls_in_over == 6:
            self.overs_bowled += 1
            self._balls_in_over = 0
            # Check for maiden over (only if no runs were scored on legal deliveries in the over)
            over_runs = self.current_bowler.bowling_stats["runs_given"] - sum(p.batting_stats["runs"] for p in self.batting_team.players if p in self.current_batsmen)
            if over_runs == 0:
                 self.current_bowler.bowling_stats["maidens"] += 1
            self._swap_strike() # Swap strike at the end of the over

        else:
            self.overs_bowled += 0.1 # Represent fractional overs


    def set_current_batsmen(self, batsman1, batsman2):
        self.current_batsmen = [batsman1, batsman2]
        self.striker = batsman1
        self.non_striker = batsman2
        for batsman in self.current_batsmen:
            if batsman not in self.batsmen:
                self.batsmen.append(batsman)


    def set_current_bowler(self, bowler):
        self.current_bowler = bowler
        if bowler not in self.bowlers:
            self.bowlers.append(bowler)

    def _swap_strike(self):
        self.striker, self.non_striker = self.non_striker, self.striker

    def play_ball(self, event_details):
        event_type = event_details["event_type"]

        if event_type == "run":
            runs = event_details["runs"]
            self.add_runs(runs)
            self._add_ball()
        elif event_type == "wicket":
            how_out = event_details["how_out"]
            self.add_wicket(how_out)
            self._add_ball()
            if self.wickets < 10: # If innings not over, bring in new batsman
                 available_batsmen = [p for p in self.batting_team.players if p not in self.batsmen and not p.batting_stats["is_out"]]
                 if available_batsmen:
                     new_batsman = select_player(self.batting_team, "Select the new batsman:")
                     while new_batsman in self.batsmen or new_batsman.batting_stats["is_out"]:
                          print("This player has already batted or is out. Select another player.")
                          new_batsman = select_player(self.batting_team, "Select the new batsman:")
                     self.current_batsmen.append(new_batsman)
                     self.batsmen.append(new_batsman)
                     self.striker = new_batsman # New batsman is usually the striker
                 else:
                      print("No more batsmen available.")

        elif event_type == "boundary":
            runs = event_details["runs"]
            self.add_runs(runs)
            self._add_ball()
        elif event_type == "extra":
            extra_type = event_details["extra_type"]
            runs = event_details.get("runs", 1) # Default to 1 run for most extras
            self.add_runs(runs, is_extra=True, extra_type=extra_type)
            self._add_ball(is_extra=True, extra_type=extra_type)
            if extra_type in ["wide", "no-ball"]:
                print(f"{extra_type.capitalize()} bowled. Another ball to be bowled.")

        # Handle strike change after a legal delivery if odd number of runs are scored
        if event_type not in ["extra"]: # Strike doesn't change automatically for most extras
             if self._balls_in_over != 0 and event_type != "wicket" and event_details.get("runs", 0) % 2 != 0:
                  self._swap_strike()

    def display_scorecard(self):
        """Prints the current score, wickets, and overs bowled for the innings."""
        print(f"\n--- {self.batting_team.name} Innings ---")
        print(f"Score: {self.runs}/{self.wickets}")
        print(f"Overs: {self.overs_bowled:.1f}")
        if self.target is not None:
            print(f"Target: {self.target}")
            runs_needed = self.target - self.runs
            balls_remaining = (self.max_overs - self.overs_bowled) * 6 - self._balls_in_over if self.max_overs is not None else "N/A"
            print(f"Runs needed: {runs_needed}")
            if isinstance(balls_remaining, (int, float)):
                 print(f"Balls remaining: {int(balls_remaining)}")

        print(f"Current Batsmen: {self.striker.name} ({self.striker.batting_stats['runs']}) and {self.non_striker.name} ({self.non_striker.batting_stats['runs']})")
        if self.current_bowler:
             print(f"Current Bowler: {self.current_bowler.name} ({self.current_bowler.bowling_stats['wickets']}/{self.current_bowler.bowling_stats['runs_given']})")
        print("--------------------------")


    def is_innings_over(self):
        if self.wickets >= 10:
            print(f"{self.batting_team.name} all out!")
            return True
        if self.max_overs is not None and self.overs_bowled >= self.max_overs:
            print(f"{self.batting_team.name} finished their overs.")
            return True
        if self.target is not None and self.runs >= self.target:
            print(f"{self.batting_team.name} chased down the target!")
            return True
        return False


class Match:
    def __init__(self, team1, team2, max_overs=None):
        self.team1 = team1  # Team object
        self.team2 = team2  # Team object
        self.innings = []  # list of Innings objects
        self.result = None
        self.max_overs = max_overs

    def start_match(self):
        print("Match started!")
        # Decide which team bats first (e.g., through a coin toss)
        # For simplicity, let's say team1 bats first
        batting_team = self.team1
        bowling_team = self.team2
        self.start_innings(batting_team, bowling_team)


    def start_innings(self, batting_team, bowling_team, target=None):
        print(f"\n{batting_team.name} are batting, {bowling_team.name} are bowling.")
        innings = Innings(batting_team, bowling_team, max_overs=self.max_overs, target=target)
        self.innings.append(innings)

        # Select opening batsmen and bowler
        opener1 = select_player(batting_team, f"Select the first opening batsman for {batting_team.name}:")
        opener2 = select_player(batting_team, f"Select the second opening batsman for {batting_team.name}:")
        first_bowler = select_player(bowling_team, f"Select the first bowler for {bowling_team.name}:")

        innings.set_current_batsmen(opener1, opener2)
        innings.set_current_bowler(first_bowler)

        print(f"{innings.striker.name} and {innings.non_striker.name} are batting.")
        print(f"{innings.current_bowler.name} is bowling.")


    def play_match(self):
        self.start_match()

        # First Innings
        current_innings = self.innings[-1]
        while not current_innings.is_innings_over():
            current_innings.display_scorecard() # Display scorecard before each ball/event

            event_details = get_event_input()
            current_innings.play_ball(event_details)

            if current_innings._balls_in_over == 0 and not current_innings.is_innings_over(): # End of an over
                new_bowler = select_player(current_innings.bowling_team, f"Select the next bowler for {current_innings.bowling_team.name}:")
                current_innings.set_current_bowler(new_bowler)
                print(f"{current_innings.current_bowler.name} is now bowling.")


        print(f"\nEnd of 1st Innings. {current_innings.batting_team.name} scored {current_innings.runs}/{current_innings.wickets} in {current_innings.overs_bowled:.1f} overs.")

        # Second Innings
        target = current_innings.runs + 1
        print(f"\nTarget for {self.team2.name} is {target}")
        self.start_innings(self.team2, self.team1, target=target)
        current_innings = self.innings[-1]

        while not current_innings.is_innings_over():
            current_innings.display_scorecard() # Display scorecard before each ball/event

            event_details = get_event_input()
            current_innings.play_ball(event_details)

            if current_innings._balls_in_over == 0 and not current_innings.is_innings_over(): # End of an over
                new_bowler = select_player(current_innings.bowling_team, f"Select the next bowler for {current_innings.bowling_team.name}:")
                current_innings.set_current_bowler(new_bowler)
                print(f"{current_innings.current_bowler.name} is now bowling.")

        print(f"\nEnd of 2nd Innings. {current_innings.batting_team.name} scored {current_innings.runs}/{current_innings.wickets} in {current_innings.overs_bowled:.1f} overs.")

        # Determine Match Result
        if current_innings.runs > self.innings[0].runs:
            self.result = f"{self.team2.name} won by {10 - current_innings.wickets} wickets."
        elif current_innings.runs < self.innings[0].runs:
            self.result = f"{self.team1.name} won by {self.innings[0].runs - current_innings.runs} runs."
        else:
            self.result = "Match Tied."

        print(f"\nMatch Result: {self.result}")

"""## Add advanced features (optional)

### Subtask:
Implement features like tracking individual player statistics, generating scorecards, or handling different match formats (e.g., T20, ODI, Test).

**Reasoning**:
Implement the `generate_scorecard` method in the `Innings` class to display detailed batting and bowling statistics for all players who participated, and also include optional features for match format and additional player statistics like strike rate and economy rate.
"""

class Player:
    def __init__(self, name):
        self.name = name
        self.batting_stats = {"runs": 0, "balls_faced": 0, "fours": 0, "sixes": 0, "is_out": False, "how_out": None}
        self.bowling_stats = {"overs": 0, "runs_given": 0, "wickets": 0, "maidens": 0}

class Team:
    def __init__(self, name, players):
        self.name = name
        self.players = players  # list of Player objects

class Innings:
    def __init__(self, batting_team, bowling_team, max_overs=None, target=None):
        self.batting_team = batting_team  # Team object
        self.bowling_team = bowling_team  # Team object
        self.runs = 0
        self.wickets = 0
        self.overs_bowled = 0.0
        self.batsmen = []  # list of batsmen who have batted (Player objects)
        self.bowlers = []  # list of bowlers who have bowled (Player objects)
        self.current_batsmen = [] # list of current batsmen at the crease (Player objects)
        self.current_bowler = None # current bowler (Player object)
        self._balls_in_over = 0
        self.max_overs = max_overs
        self.target = target
        self.striker = None
        self.non_striker = None

    def add_runs(self, runs, is_extra=False, extra_type=None):
        self.runs += runs
        if not is_extra:
            self.striker.batting_stats["runs"] += runs
            self.striker.batting_stats["balls_faced"] += 1
            if runs == 4:
                self.striker.batting_stats["fours"] += 1
            elif runs == 6:
                self.striker.batting_stats["sixes"] += 1
            if runs % 2 != 0:
                self._swap_strike()
        else:
            if self.current_bowler:
                self.current_bowler.bowling_stats["runs_given"] += runs # Extras also add to bowler's runs
            if extra_type in ["wide", "no-ball"]:
                 # Wide and no-ball don't count as a legal delivery
                return

        if self.current_bowler:
            self.current_bowler.bowling_stats["runs_given"] += runs


    def add_wicket(self, how_out):
        self.wickets += 1
        self.striker.batting_stats["is_out"] = True
        self.striker.batting_stats["how_out"] = how_out
        self.striker.batting_stats["balls_faced"] += 1
        if self.striker in self.current_batsmen:
            self.current_batsmen.remove(self.striker)
        if self.current_bowler:
            self.current_bowler.bowling_stats["wickets"] += 1


    def _add_ball(self, is_extra=False, extra_type=None):
        if is_extra and extra_type in ["wide", "no-ball"]:
            # Wide and no-ball do not count as a legal delivery in the over
            return

        self._balls_in_over += 1
        if self._balls_in_over == 6:
            self.overs_bowled += 1
            self._balls_in_over = 0
            # Check for maiden over (only if no runs were scored on legal deliveries in the over)
            over_runs = self.current_bowler.bowling_stats["runs_given"] - sum(p.batting_stats["runs"] for p in self.batting_team.players if p in self.current_batsmen)
            if over_runs == 0:
                 self.current_bowler.bowling_stats["maidens"] += 1
            self._swap_strike() # Swap strike at the end of the over

        else:
            self.overs_bowled += 0.1 # Represent fractional overs


    def set_current_batsmen(self, batsman1, batsman2):
        self.current_batsmen = [batsman1, batsman2]
        self.striker = batsman1
        self.non_striker = batsman2
        for batsman in self.current_batsmen:
            if batsman not in self.batsmen:
                self.batsmen.append(batsman)


    def set_current_bowler(self, bowler):
        self.current_bowler = bowler
        if bowler not in self.bowlers:
            self.bowlers.append(bowler)

    def _swap_strike(self):
        self.striker, self.non_striker = self.non_striker, self.striker

    def play_ball(self, event_details):
        event_type = event_details["event_type"]

        if event_type == "run":
            runs = event_details["runs"]
            self.add_runs(runs)
            self._add_ball()
        elif event_type == "wicket":
            how_out = event_details["how_out"]
            self.add_wicket(how_out)
            self._add_ball()
            if self.wickets < 10: # If innings not over, bring in new batsman
                 available_batsmen = [p for p in self.batting_team.players if p not in self.batsmen and not p.batting_stats["is_out"]]
                 if available_batsmen:
                     new_batsman = select_player(self.batting_team, "Select the new batsman:")
                     while new_batsman in self.batsmen or new_batsman.batting_stats["is_out"]:
                          print("This player has already batted or is out. Select another player.")
                          new_batsman = select_player(self.batting_team, "Select the new batsman:")
                     self.current_batsmen.append(new_batsman)
                     self.batsmen.append(new_batsman)
                     self.striker = new_batsman # New batsman is usually the striker
                 else:
                      print("No more batsmen available.")

        elif event_type == "boundary":
            runs = event_details["runs"]
            self.add_runs(runs)
            self._add_ball()
        elif event_type == "extra":
            extra_type = event_details["extra_type"]
            runs = event_details.get("runs", 1) # Default to 1 run for most extras
            self.add_runs(runs, is_extra=True, extra_type=extra_type)
            self._add_ball(is_extra=True, extra_type=extra_type)
            if extra_type in ["wide", "no-ball"]:
                print(f"{extra_type.capitalize()} bowled. Another ball to be bowled.")

        # Handle strike change after a legal delivery if odd number of runs are scored
        if event_type not in ["extra"]: # Strike doesn't change automatically for most extras
             if self._balls_in_over != 0 and event_type != "wicket" and event_details.get("runs", 0) % 2 != 0:
                  self._swap_strike()

    def display_scorecard(self):
        """Prints the current score, wickets, and overs bowled for the innings."""
        print(f"\n--- {self.batting_team.name} Innings ---")
        print(f"Score: {self.runs}/{self.wickets}")
        print(f"Overs: {self.overs_bowled:.1f}")
        if self.target is not None:
            print(f"Target: {self.target}")
            runs_needed = self.target - self.runs
            balls_remaining = (self.max_overs - self.overs_bowled) * 6 - self._balls_in_over if self.max_overs is not None else "N/A"
            print(f"Runs needed: {runs_needed}")
            if isinstance(balls_remaining, (int, float)):
                 print(f"Balls remaining: {int(balls_remaining)}")

        print(f"Current Batsmen: {self.striker.name} ({self.striker.batting_stats['runs']}) and {self.non_striker.name} ({self.non_striker.batting_stats['runs']})")
        if self.current_bowler:
             print(f"Current Bowler: {self.current_bowler.name} ({self.current_bowler.bowling_stats['wickets']}/{self.current_bowler.bowling_stats['runs_given']})")
        print("--------------------------")

    def generate_scorecard(self):
        """Generates and prints a detailed scorecard for the innings."""
        print(f"\n--- {self.batting_team.name} Scorecard ---")
        print("Batsmen                 Runs  Balls  4s  6s  Strike Rate  How Out")
        print("-----------------------------------------------------------------")
        for player in self.batsmen:
            sr = (player.batting_stats['runs'] / player.batting_stats['balls_faced']) * 100 if player.batting_stats['balls_faced'] > 0 else 0
            how_out = player.batting_stats['how_out'] if player.batting_stats['is_out'] else "Not out"
            print(f"{player.name:<20}{player.batting_stats['runs']:<6}{player.batting_stats['balls_faced']:<7}{player.batting_stats['fours']:<4}{player.batting_stats['sixes']:<4}{sr:<13.2f}{how_out}")
        print("-----------------------------------------------------------------")
        print(f"Total: {self.runs}/{self.wickets} in {self.overs_bowled:.1f} overs\n")

        print(f"--- {self.bowling_team.name} Bowling ---")
        print("Bowler                  Overs  Maidens  Runs  Wickets  Economy Rate")
        print("---------------------------------------------------------------------")
        for bowler in self.bowlers:
            er = (bowler.bowling_stats['runs_given'] / bowler.bowling_stats['overs']) if bowler.bowling_stats['overs'] > 0 else bowler.bowling_stats['runs_given']
            print(f"{bowler.name:<20}{bowler.bowling_stats['overs']:<7.1f}{bowler.bowling_stats['maidens']:<9}{bowler.bowling_stats['runs_given']:<6}{bowler.bowling_stats['wickets']:<9}{er:<13.2f}")
        print("---------------------------------------------------------------------")


    def is_innings_over(self):
        if self.wickets >= 10:
            print(f"{self.batting_team.name} all out!")
            return True
        if self.max_overs is not None and self.overs_bowled >= self.max_overs:
            print(f"{self.batting_team.name} finished their overs.")
            return True
        if self.target is not None and self.runs >= self.target:
            print(f"{self.batting_team.name} chased down the target!")
            return True
        return False


class Match:
    def __init__(self, team1, team2, match_format="ODI"):
        self.team1 = team1  # Team object
        self.team2 = team2  # Team object
        self.innings = []  # list of Innings objects
        self.result = None
        self.match_format = match_format
        self.max_overs = self._set_max_overs(match_format)


    def _set_max_overs(self, match_format):
        if match_format == "T20":
            return 20
        elif match_format == "ODI":
            return 50
        elif match_format == "Test":
            return None # Test matches don't have a fixed max_overs per innings
        else:
            return 50 # Default to ODI overs


    def start_match(self):
        print(f"Match started! Format: {self.match_format}")
        # Decide which team bats first (e.g., through a coin toss)
        # For simplicity, let's say team1 bats first
        batting_team = self.team1
        bowling_team = self.team2
        self.start_innings(batting_team, bowling_team)


    def start_innings(self, batting_team, bowling_team, target=None):
        print(f"\n{batting_team.name} are batting, {bowling_team.name} are bowling.")
        innings = Innings(batting_team, bowling_team, max_overs=self.max_overs, target=target)
        self.innings.append(innings)

        # Select opening batsmen and bowler
        opener1 = select_player(batting_team, f"Select the first opening batsman for {batting_team.name}:")
        opener2 = select_player(batting_team, f"Select the second opening batsman for {batting_team.name}:")
        first_bowler = select_player(bowling_team, f"Select the first bowler for {bowling_team.name}:")

        innings.set_current_batsmen(opener1, opener2)
        innings.set_current_bowler(first_bowler)

        print(f"{innings.striker.name} and {innings.non_striker.name} are batting.")
        print(f"{innings.current_bowler.name} is bowling.")


    def play_match(self):
        self.start_match()

        # First Innings
        current_innings = self.innings[-1]
        while not current_innings.is_innings_over():
            current_innings.display_scorecard() # Display scorecard before each ball/event

            event_details = get_event_input()
            current_innings.play_ball(event_details)

            if current_innings._balls_in_over == 0 and not current_innings.is_innings_over(): # End of an over
                new_bowler = select_player(current_innings.bowling_team, f"Select the next bowler for {current_innings.bowling_team.name}:")
                current_innings.set_current_bowler(new_bowler)
                print(f"{current_innings.current_bowler.name} is now bowling.")


        print(f"\nEnd of 1st Innings. {current_innings.batting_team.name} scored {current_innings.runs}/{current_innings.wickets} in {current_innings.overs_bowled:.1f} overs.")
        current_innings.generate_scorecard() # Generate scorecard at the end of the innings

        # Second Innings
        target = current_innings.runs + 1
        print(f"\nTarget for {self.team2.name} is {target}")
        self.start_innings(self.team2, self.team1, target=target)
        current_innings = self.innings[-1]

        while not current_innings.is_innings_over():
            current_innings.display_scorecard() # Display scorecard before each ball/event

            event_details = get_event_input()
            current_innings.play_ball(event_details)

            if current_innings._balls_in_over == 0 and not current_innings.is_innings_over(): # End of an over
                new_bowler = select_player(current_innings.bowling_team, f"Select the next bowler for {current_innings.bowling_team.name}:")
                current_innings.set_current_bowler(new_bowler)
                print(f"{current_innings.current_bowler.name} is now bowling.")

        print(f"\nEnd of 2nd Innings. {current_innings.batting_team.name} scored {current_innings.runs}/{current_innings.wickets} in {current_innings.overs_bowled:.1f} overs.")
        current_innings.generate_scorecard() # Generate scorecard at the end of the innings

        # Determine Match Result
        if current_innings.runs > self.innings[0].runs:
            self.result = f"{self.team2.name} won by {10 - current_innings.wickets} wickets."
        elif current_innings.runs < self.innings[0].runs:
            self.result = f"{self.team1.name} won by {self.innings[0].runs - current_innings.runs} runs."
        else:
            self.result = "Match Tied."

        print(f"\nMatch Result: {self.result}")

"""## Summary:

### Data Analysis Key Findings

*   The core Python classes (`Player`, `Team`, `Innings`, and `Match`) were successfully defined to structure the cricket score management application.
*   Basic scoring functionality was implemented in the `Innings` class, allowing for the recording of runs, wickets, and overs, and updating individual player statistics in the `Player` class.
*   Input handling functions were created to take user input for match events and player selections, including validation for integer and string inputs.
*   The match flow logic was developed within the `Match` and `Innings` classes to manage the progression of an innings and the overall match, including starting innings, processing events, handling overs, and determining the innings and match outcomes.
*   A `display_scorecard` method was added to the `Innings` class to show the current match status (score, wickets, overs, target, runs needed, balls remaining, current batsmen, current bowler).
*   An advanced `generate_scorecard` method was added to the `Innings` class to display detailed batting and bowling statistics at the end of an innings, including calculated strike rates and economy rates.
*   The `Match` class was extended to handle different `match_format` types ("T20", "ODI", "Test") by setting the appropriate maximum overs.

### Insights or Next Steps

*   The current implementation provides a solid foundation for a cricket score management application.
*   Further development could include implementing more detailed statistics tracking (e.g., individual ball-by-ball data, partnerships), handling more complex dismissal types, saving/loading match data, and creating a more user-friendly interface.

## Implement basic scoring

### Subtask:
Add functionality to record runs, wickets, and overs.

**Reasoning**:
Add methods to the `Innings` class to handle adding runs, wickets, and overs/balls, and update the `Player` class to track batting and bowling statistics.
"""

class Player:
    def __init__(self, name):
        self.name = name
        self.batting_stats = {"runs": 0, "balls_faced": 0, "fours": 0, "sixes": 0, "is_out": False, "how_out": None}
        self.bowling_stats = {"overs": 0, "runs_given": 0, "wickets": 0, "maidens": 0}

class Team:
    def __init__(self, name, players):
        self.name = name
        self.players = players  # list of Player objects

class Innings:
    def __init__(self, batting_team, bowling_team, max_overs=None, target=None):
        self.batting_team = batting_team  # Team object
        self.bowling_team = bowling_team  # Team object
        self.runs = 0
        self.wickets = 0
        self.overs_bowled = 0.0
        self.batsmen = []  # list of batsmen who have batted (Player objects)
        self.bowlers = []  # list of bowlers who have bowled (Player objects)
        self.current_batsmen = [] # list of current batsmen at the crease (Player objects)
        self.current_bowler = None # current bowler (Player object)
        self._balls_in_over = 0
        self.max_overs = max_overs
        self.target = target
        self.striker = None
        self.non_striker = None

    def add_runs(self, runs, is_extra=False, extra_type=None):
        self.runs += runs
        if not is_extra:
            self.striker.batting_stats["runs"] += runs
            self.striker.batting_stats["balls_faced"] += 1
            if runs == 4:
                self.striker.batting_stats["fours"] += 1
            elif runs == 6:
                self.striker.batting_stats["sixes"] += 1
            if runs % 2 != 0:
                self._swap_strike()
        else:
            if self.current_bowler:
                self.current_bowler.bowling_stats["runs_given"] += runs # Extras also add to bowler's runs
            if extra_type in ["wide", "no-ball"]:
                 # Wide and no-ball don't count as a legal delivery
                return

        if self.current_bowler:
            self.current_bowler.bowling_stats["runs_given"] += runs


    def add_wicket(self, how_out):
        self.wickets += 1
        self.striker.batting_stats["is_out"] = True
        self.striker.batting_stats["how_out"] = how_out
        self.striker.batting_stats["balls_faced"] += 1
        if self.striker in self.current_batsmen:
            self.current_batsmen.remove(self.striker)
        if self.current_bowler:
            self.current_bowler.bowling_stats["wickets"] += 1


    def _add_ball(self, is_extra=False, extra_type=None):
        if is_extra and extra_type in ["wide", "no-ball"]:
            # Wide and no-ball do not count as a legal delivery in the over
            return

        self._balls_in_over += 1
        if self._balls_in_over == 6:
            self.overs_bowled += 1
            self._balls_in_over = 0
            # Check for maiden over (only if no runs were scored on legal deliveries in the over)
            over_runs = self.current_bowler.bowling_stats["runs_given"] - sum(p.batting_stats["runs"] for p in self.batting_team.players if p in self.current_batsmen)
            if over_runs == 0:
                 self.current_bowler.bowling_stats["maidens"] += 1
            self._swap_strike() # Swap strike at the end of the over

        else:
            self.overs_bowled += 0.1 # Represent fractional overs


    def set_current_batsmen(self, batsman1, batsman2):
        self.current_batsmen = [batsman1, batsman2]
        self.striker = batsman1
        self.non_striker = batsman2
        for batsman in self.current_batsmen:
            if batsman not in self.batsmen:
                self.batsmen.append(batsman)


    def set_current_bowler(self, bowler):
        self.current_bowler = bowler
        if bowler not in self.bowlers:
            self.bowlers.append(bowler)

    def _swap_strike(self):
        self.striker, self.non_striker = self.non_striker, self.striker

    def play_ball(self, event_details):
        event_type = event_details["event_type"]

        if event_type == "run":
            runs = event_details["runs"]
            self.add_runs(runs)
            self._add_ball()
        elif event_type == "wicket":
            how_out = event_details["how_out"]
            self.add_wicket(how_out)
            self._add_ball()
            if self.wickets < 10: # If innings not over, bring in new batsman
                 available_batsmen = [p for p in self.batting_team.players if p not in self.batsmen and not p.batting_stats["is_out"]]
                 if available_batsmen:
                     new_batsman = select_player(self.batting_team, "Select the new batsman:")
                     while new_batsman in self.batsmen or new_batsman.batting_stats["is_out"]:
                          print("This player has already batted or is out. Select another player.")
                          new_batsman = select_player(self.batting_team, "Select the new batsman:")
                     self.current_batsmen.append(new_batsman)
                     self.batsmen.append(new_batsman)
                     self.striker = new_batsman # New batsman is usually the striker
                 else:
                      print("No more batsmen available.")

        elif event_type == "boundary":
            runs = event_details["runs"]
            self.add_runs(runs)
            self._add_ball()
        elif event_type == "extra":
            extra_type = event_details["extra_type"]
            runs = event_details.get("runs", 1) # Default to 1 run for most extras
            self.add_runs(runs, is_extra=True, extra_type=extra_type)
            self._add_ball(is_extra=True, extra_type=extra_type)
            if extra_type in ["wide", "no-ball"]:
                print(f"{extra_type.capitalize()} bowled. Another ball to be bowled.")

        # Handle strike change after a legal delivery if odd number of runs are scored
        if event_type not in ["extra"]: # Strike doesn't change automatically for most extras
             if self._balls_in_over != 0 and event_type != "wicket" and event_details.get("runs", 0) % 2 != 0:
                  self._swap_strike()

    def display_scorecard(self):
        """Prints the current score, wickets, and overs bowled for the innings."""
        print(f"\n--- {self.batting_team.name} Innings ---")
        print(f"Score: {self.runs}/{self.wickets}")
        print(f"Overs: {self.overs_bowled:.1f}")
        if self.target is not None:
            print(f"Target: {self.target}")
            runs_needed = self.target - self.runs
            balls_remaining = (self.max_overs - self.overs_bowled) * 6 - self._balls_in_over if self.max_overs is not None else "N/A"
            print(f"Runs needed: {runs_needed}")
            if isinstance(balls_remaining, (int, float)):
                 print(f"Balls remaining: {int(balls_remaining)}")

        print(f"Current Batsmen: {self.striker.name} ({self.striker.batting_stats['runs']}) and {self.non_striker.name} ({self.non_striker.batting_stats['runs']})")
        if self.current_bowler:
             print(f"Current Bowler: {self.current_bowler.name} ({self.current_bowler.bowling_stats['wickets']}/{self.current_bowler.bowling_stats['runs_given']})")
        print("--------------------------")

    def generate_scorecard(self):
        """Generates and prints a detailed scorecard for the innings."""
        print(f"\n--- {self.batting_team.name} Scorecard ---")
        print("Batsmen                 Runs  Balls  4s  6s  Strike Rate  How Out")
        print("-----------------------------------------------------------------")
        for player in self.batsmen:
            sr = (player.batting_stats['runs'] / player.batting_stats['balls_faced']) * 100 if player.batting_stats['balls_faced'] > 0 else 0
            how_out = player.batting_stats['how_out'] if player.batting_stats['is_out'] else "Not out"
            print(f"{player.name:<20}{player.batting_stats['runs']:<6}{player.batting_stats['balls_faced']:<7}{player.batting_stats['fours']:<4}{player.batting_stats['sixes']:<4}{sr:<13.2f}{how_out}")
        print("-----------------------------------------------------------------")
        print(f"Total: {self.runs}/{self.wickets} in {self.overs_bowled:.1f} overs\n")

        print(f"--- {self.bowling_team.name} Bowling ---")
        print("Bowler                  Overs  Maidens  Runs  Wickets  Economy Rate")
        print("---------------------------------------------------------------------")
        for bowler in self.bowlers:
            er = (bowler.bowling_stats['runs_given'] / bowler.bowling_stats['overs']) if bowler.bowling_stats['overs'] > 0 else bowler.bowling_stats['runs_given']
            print(f"{bowler.name:<20}{bowler.bowling_stats['overs']:<7.1f}{bowler.bowling_stats['maidens']:<9}{bowler.bowling_stats['runs_given']:<6}{bowler.bowling_stats['wickets']:<9}{er:<13.2f}")
        print("---------------------------------------------------------------------")


    def is_innings_over(self):
        if self.wickets >= 10:
            print(f"{self.batting_team.name} all out!")
            return True
        if self.max_overs is not None and self.overs_bowled >= self.max_overs:
            print(f"{self.batting_team.name} finished their overs.")
            return True
        if self.target is not None and self.runs >= self.target:
            print(f"{self.batting_team.name} chased down the target!")
            return True
        return False


class Match:
    def __init__(self, team1, team2, match_format="ODI"):
        self.team1 = team1  # Team object
        self.team2 = team2  # Team object
        self.innings = []  # list of Innings objects
        self.result = None
        self.match_format = match_format
        self.max_overs = self._set_max_overs(match_format)


    def _set_max_overs(self, match_format):
        if match_format == "T20":
            return 20
        elif match_format == "ODI":
            return 50
        elif match_format == "Test":
            return None # Test matches don't have a fixed max_overs per innings
        else:
            return 50 # Default to ODI overs


    def start_match(self):
        print(f"Match started! Format: {self.match_format}")
        # Decide which team bats first (e.g., through a coin toss)
        # For simplicity, let's say team1 bats first
        batting_team = self.team1
        bowling_team = self.team2
        self.start_innings(batting_team, bowling_team)


    def start_innings(self, batting_team, bowling_team, target=None):
        print(f"\n{batting_team.name} are batting, {bowling_team.name} are bowling.")
        innings = Innings(batting_team, bowling_team, max_overs=self.max_overs, target=target)
        self.innings.append(innings)

        # Select opening batsmen and bowler
        opener1 = select_player(batting_team, f"Select the first opening batsman for {batting_team.name}:")
        opener2 = select_player(batting_team, f"Select the second opening batsman for {batting_team.name}:")
        first_bowler = select_player(bowling_team, f"Select the first bowler for {bowling_team.name}:")

        innings.set_current_batsmen(opener1, opener2)
        innings.set_current_bowler(first_bowler)

        print(f"{innings.striker.name} and {innings.non_striker.name} are batting.")
        print(f"{innings.current_bowler.name} is bowling.")


    def play_match(self):
        self.start_match()

        # First Innings
        current_innings = self.innings[-1]
        while not current_innings.is_innings_over():
            current_innings.display_scorecard() # Display scorecard before each ball/event

            event_details = get_event_input()
            current_innings.play_ball(event_details)

            if current_innings._balls_in_over == 0 and not current_innings.is_innings_over(): # End of an over
                new_bowler = select_player(current_innings.bowling_team, f"Select the next bowler for {current_innings.bowling_team.name}:")
                current_innings.set_current_bowler(new_bowler)
                print(f"{current_innings.current_bowler.name} is now bowling.")


        print(f"\nEnd of 1st Innings. {current_innings.batting_team.name} scored {current_innings.runs}/{current_innings.wickets} in {current_innings.overs_bowled:.1f} overs.")
        current_innings.generate_scorecard() # Generate scorecard at the end of the innings

        # Second Innings
        target = current_innings.runs + 1
        print(f"\nTarget for {self.team2.name} is {target}")
        self.start_innings(self.team2, self.team1, target=target)
        current_innings = self.innings[-1]

        while not current_innings.is_innings_over():
            current_innings.display_scorecard() # Display scorecard before each ball/event

            event_details = get_event_input()
            current_innings.play_ball(event_details)

            if current_innings._balls_in_over == 0 and not current_innings.is_innings_over(): # End of an over
                new_bowler = select_player(current_innings.bowling_team, f"Select the next bowler for {current_innings.bowling_team.name}:")
                current_innings.set_current_bowler(new_bowler)
                print(f"{current_innings.current_bowler.name} is now bowling.")

        print(f"\nEnd of 2nd Innings. {current_innings.batting_team.name} scored {current_innings.runs}/{current_innings.wickets} in {current_innings.overs_bowled:.1f} overs.")
        current_innings.generate_scorecard() # Generate scorecard at the end of the innings

        # Determine Match Result
        if current_innings.runs > self.innings[0].runs:
            self.result = f"{self.team2.name} won by {10 - current_innings.wickets} wickets."
        elif current_innings.runs < self.innings[0].runs:
            self.result = f"{self.team1.name} won by {self.innings[0].runs - current_innings.runs} runs."
        else:
            self.result = "Match Tied."

        print(f"\nMatch Result: {self.result}")

"""## Add input handling

### Subtask:
Create functions to take user input for scores and events during a match.

**Reasoning**:
The subtask requires creating four functions for handling user input: getting integer input, getting string input, getting event input, and selecting a player. I will create these four functions in a single code block.
"""

def get_integer_input(prompt):
    """Gets valid integer input from the user."""
    while True:
        try:
            value = int(input(prompt))
            return value
        except ValueError:
            print("Invalid input. Please enter an integer.")

def get_string_input(prompt):
    """Gets valid non-empty string input from the user."""
    while True:
        value = input(prompt).strip()
        if value:
            return value
        else:
            print("Invalid input. Please enter a non-empty string.")

def get_event_input():
    """Prompts the user for event details and returns a dictionary."""
    event_type = get_string_input("Enter event type (e.g., run, wicket, boundary): ").lower()
    event_details = {"event_type": event_type}

    if event_type == "run":
        runs = get_integer_input("Enter number of runs: ")
        event_details["runs"] = runs
    elif event_type == "wicket":
        how_out = get_string_input("Enter how the batsman was out: ")
        event_details["how_out"] = how_out
    elif event_type == "boundary":
        boundary_type = get_integer_input("Enter boundary type (4 or 6): ")
        event_details["boundary_type"] = boundary_type
        event_details["runs"] = boundary_type # Also add runs for boundary
    # Add more event types as needed

    return event_details

def select_player(team, prompt):
    """Displays players in a team and prompts the user to select one."""
    print(prompt)
    for i, player in enumerate(team.players):
        print(f"{i + 1}. {player.name}")

    while True:
        selection = get_integer_input("Enter player number: ")
        if 1 <= selection <= len(team.players):
            return team.players[selection - 1]
        else:
            print("Invalid selection. Please enter a valid player number.")

"""## Summary:

### Data Analysis Key Findings

* The core Python classes (`Player`, `Team`, `Innings`, and `Match`) were successfully defined to structure the cricket score management application.
* Basic scoring functionality was implemented in the `Innings` class, allowing for the recording of runs, wickets, and overs, and updating individual player statistics in the `Player` class.
* Input handling functions were created to take user input for match events and player selections, including validation for integer and string inputs.
* The match flow logic was developed within the `Match` and `Innings` classes to manage the progression of an innings and the overall match, including starting innings, processing events, handling overs, and determining the innings and match outcomes.
* A `display_scorecard` method was added to the `Innings` class to show the current match status (score, wickets, overs, target, runs needed, balls remaining, current batsmen, current bowler).
* An advanced `generate_scorecard` method was added to the `Innings` class to display detailed batting and bowling statistics at the end of an innings, including calculated strike rates and economy rates.
* The `Match` class was extended to handle different `match_format` types ("T20", "ODI", "Test") by setting the appropriate maximum overs.

### Insights or Next Steps

* The current implementation provides a solid foundation for a cricket score management application.
* Further development could include implementing more detailed statistics tracking (e.g., individual ball-by-ball data, partnerships), handling more complex dismissal types, saving/loading match data, and creating a more user-friendly interface.

### How to Use the Application

1. **Define Players**: Create `Player` objects for all players participating in the match.
2. **Create Teams**: Create `Team` objects for each team, passing the team name and a list of `Player` objects.
3. **Create Match**: Create a `Match` object with the two teams and optionally specify the `match_format` (e.g., `Match(team1, team2, match_format="T20")`).
4. **Play Match**: Call the `play_match()` method on the `Match` object to start and manage the match. The application will prompt you for input for each event (runs, wickets, boundaries, extras).
"""